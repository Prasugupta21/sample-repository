/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */

1.brute Force O(n^2)

class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode*temp1=headA;
        ListNode*temp2=headB;
        
        while(temp1){
            temp2=headB;
            while(temp2){
               if(temp1==temp2){
                   return temp1;
                   
               }
                temp2=temp2->next;
            }
    temp1=temp1->next;
        }
        return NULL;
    }
};

2. time com. O(n+m)   and space complexticy O(n)
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode*temp1=headA;
        ListNode*temp2=headB;
        unordered_map<ListNode*,int>m;
        
        
        while(temp1){
          m[temp1]++;
            
          
    temp1=temp1->next;
        }
        while(temp2){
            if(m.count(temp2)){
                return temp2;
            }
                      
    temp2=temp2->next;
        }
        return NULL;
    }
};

Optimal O(m+n) and constant space 

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:

    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode*temp1=headA;
        ListNode*temp2=headB;
while((temp1 ) &&(temp2)){
   if(temp1==temp2){
       return temp1;
   } 
    temp1=temp1->next;
    temp2=temp2->next;
    if((!temp1)&&(!temp2)){
        break;
    }
    else if(!temp1){
        temp1=headB;
    }
    else if(!temp2){
       temp2=headA;
        }
}
return NULL;
    }
    
};

/* Another  Implementation of Above Optimal Approach  */

class Solution {
public:

    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode*temp1=headA;
        ListNode*temp2=headB;
while(temp1!=temp2){
 
    temp1=(temp1==NULL)?headB:(temp1->next);
    temp2=(temp2==NULL)?headA:(temp2->next);
    
}
return temp1;
    }
    
};