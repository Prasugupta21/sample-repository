class Solution {
public:
    int maxDepth(Node* root) {
        if(!root){
            return 0;
        }
        int ans=0;
       queue<Node*>q;
       q.push(root);
       while(!q.empty()){
           int n=q.size();
           ans++;
           while(n--){
               Node*f=q.front();
               q.pop();
               for(int i=0;i<f->children.size();i++){
                   q.push(f->children[i]);
               }
           }


       }
       return ans;
    }
};

// approach 2

class Solution {
public:
    int maxDepth(Node* root) {
        if(!root){
            return 0;
        }
        int ans=0,currDepth=0;
    stack<pair<Node*,int>>s;
    s.push({root,1});
    while(!s.empty()){
        Node *currNode=s.top().first;
    currDepth=s.top().second;
    s.pop();
ans=max(ans,currDepth);
for(auto child: currNode->children){
    s.push({child,currDepth+1});
}

    }
       
       return ans;
    }
};

//Recursive

/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    int maxDepth(Node* root) {
        if(!root){
            return 0;
        }
        if(root->children.size()==0){
            return 1;
        }
        int ans=0;
        for(int i=0;i<root->children.size();i++){
            ans=max(ans,maxDepth(root->children[i]));
        }
        return 1+ans;
    }
};