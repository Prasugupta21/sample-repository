/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:

    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string >ans;
        stack<pair<TreeNode*,string>>s;
        s.push({root,to_string(root->val)});
        while(!(s.empty())){
            pair p=s.top();
            string b=p.second;
            s.pop();
            TreeNode*f=p.first;
            if(!(f->left) && !(f->right)){
                ans.push_back(p.second);
            }
            if(f->left){
                string v=to_string (f->left->val);
                s.push({f->left,b+"->"+v});

            }
            if(f->right){
                string v=to_string (f->right->val);
                s.push({f->right,b+"->"+v});

            }
        }
        
        return ans;
    }
};

// Recursive

class Solution {
public:
void binaryTreePathHelper(TreeNode* root,vector<string>&ans,string temp){
    if(!(root->left) && !(root->right)){
        temp+=to_string(root->val);
      
        ans.push_back(temp);
        return;
    }
    temp+=to_string(root->val);
    temp+="->";
    if(root->left){
        binaryTreePathHelper(root->left,ans,temp);
    }
    if(root->right){
        binaryTreePathHelper(root->right,ans,temp);
    }
    return;
}
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string >ans;
        binaryTreePathHelper(root,ans,"");
        return ans;
    }
};
Console
