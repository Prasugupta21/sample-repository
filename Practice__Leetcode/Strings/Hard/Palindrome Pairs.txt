Brute Force Solution giving TLE

class Solution {
public:
    bool IsPalindrome(string w,int i,int j){
        while(i<j){
            if(w[i]!=w[j]){
                return false;
            }
            i++;
            j--;
        }
        return true;
    }
    vector<vector<int>> palindromePairs(vector<string>& w) {
             vector<vector<int>>ans;

        for(int i=0;i<w.size();i++){
         
            
       
          
            for(int k=0;k<w.size();k++){
                  int j=0;
                int flag=1;
                int l=w[k].size()-1;
                if(k!=i){
                    while((j<w[i].size())&&(l>=0)){
                        if(w[i][j]!=w[k][l]){
                            flag=0;
                            break;
                        }
                        j++;
                        l--;
                    }
                    if((j==w[i].size()) &&(l==-1)){
                        vector<int>v;
                        v.push_back(i);
                        v.push_back(k);
                        ans.push_back(v);
                    }
                   else if((j!=w[i].size())&&(flag)){
                        int x=w[i].size()-1;
                        if(IsPalindrome(w[i],j,x)){
                             vector<int>v;
                        v.push_back(i);
                        v.push_back(k);
                        ans.push_back(v);
                        }
                    }
                    else if((l!=-1)&&(flag)){
                        int x=0;
                        if(IsPalindrome(w[k],x,l)){
                          vector<int>v;
                        v.push_back(i);
                        v.push_back(k);
                        ans.push_back(v);  
                        }
                    }
                    
                }
                
            }
        }
        return ans;
        
    }
};


I saw on Youtube but also it is giving TLE due to including new testcases

class Solution {
public:
    bool IsPalindrome(string  &w){
        int i=0,j=w.size()-1;
        
        while(i<j){
            if(w[i]!=w[j]){
                return false;
            }
            i++;
            j--;
        }
        return true;
    }
    vector<vector<int>> palindromePairs(vector<string>& w) {
             vector<vector<int>>ans;
        unordered_map<string,int>m;
        if(w.size()<2){
            return ans;
        }

        for(int i=0;i<w.size();++i){
         auto s=w[i];
            reverse(s.begin(),s.end());
            m[s]=i;
            
     
        
        }
           for(int i=0;i<w.size();++i){
        for(int j=0;j<=w[i].size();++j){
            string s1=w[i].substr(0,j);
        string s2=w[i].substr(j);
            if((IsPalindrome(s2))&&(m.count(s1))&&(m[s1]!=i)){
                ans.push_back({i,m[s1]});
            }
                 if((IsPalindrome(s1))&&(m.count(s2))&&(m[s2]!=i)&&(!s1.empty())){
                ans.push_back({m[s2],i});
            }
             
        }
            
     
        
        }
        
        
        return ans;
        
    }
};

FInally ACCEPTED SOLUTION 

class Solution {
public:
  inline  bool IsPalindrome(string  &s,int i,int j){
       
        
        while(i<j){
            if(s[i++]!=s[j--]){
                return false;
            }

        }
        return true;
    }

    vector<vector<int>> palindromePairs(vector<string>& w) {
           
              vector<vector<int>>ans;
        unordered_map<string,int>m;
        set<int>s;
      

        for(int i=0;i<w.size();++i){
       
           
            m[w[i]]=i;
            
            s.insert(w[i].size());
            
            
     
        
        }
           for(int i=0;i<w.size();++i){
        string ss=w[i];
        int len=ss.size();
              reverse(ss.begin(),ss.end());
                if((m.count(ss))&&(m[ss]!=i)){
                ans.push_back({i,m[ss]});
                }
            auto a=s.find(len);
           for(auto it=s.begin();it!=a;++it){
               int d=*it;
               if((IsPalindrome(ss,0,len-1-d))&&(m.count(ss.substr(len-d)))){
                   ans.push_back({i,m[ss.substr(len-d)]});
               }
                     if((IsPalindrome(ss,d,len-1))&&(m.count(ss.substr(0,d)))){
                   ans.push_back({m[ss.substr(0,d)],i});
               }
           }
         
         

            }
                        
        
            
     
        
        

        
        return ans;
        
    }
};