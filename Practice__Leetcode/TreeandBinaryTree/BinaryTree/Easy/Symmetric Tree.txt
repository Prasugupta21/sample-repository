/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:

    bool isSym(TreeNode*node1,TreeNode*node2){
        if(!node1 || !node2){
            return node1==node2;
        }
        if(node1->val!=node2->val){
            return false;
        }
        return isSym(node1->left,node2->right) && isSym(node1->right,node2->left);
    }
    bool isSymmetric(TreeNode* root) {
    
     return (root==NULL || isSym(root->left,root->right));
    }
};


// approach 2


class Solution {
public:

   
    
    bool isSymmetric(TreeNode* root) {
 if(!(root->left) && !(root->right)){
     return true;
 }
 queue<TreeNode*>q1,q2;
 q1.push(root->left);
 q2.push(root->right);
 while(!q1.empty()   &&  !q2.empty()){
     TreeNode*f1=q1.front();
          TreeNode*f2=q2.front();
           q1.pop();
           q2.pop();
          if((f1 && !f2  )|| (f2 && !f1)){
              return false;
          }
          if( !f1 && !f2){
              continue;
        }
                if(f1->val!=f2->val){
                    return false;
                }
               
                q1.push(f1->left);
                q1.push(f1->right);
                q2.push(f2->right);
                q2.push(f2->left);

 }
 return true;
    }
};
class Solution {
public:
void preOrder(TreeNode*root,vector<int>&ans){
    
    if(!root){
          ans.push_back(-101);
        return;
    }
    ans.push_back(root->val);
    preOrder(root->left,ans);
    preOrder(root->right,ans);

}
void reversePreOrder(TreeNode*root,vector<int>&ans){
    
    if(!root){
        ans.push_back(-101);
        return;
    }
    ans.push_back(root->val);
    
    reversePreOrder(root->right,ans);
    reversePreOrder(root->left,ans);

}
    bool isSymmetric(TreeNode* root) {
        if(!(root->left)&& !(root->right)){
            return true;
        }
        vector<int>v1,v2,v,t;
     preOrder(root->left,v);
     reversePreOrder(root->right,t);
     if(t.size()!=v.size()){
         return false;
     }
     for(int i=0;i<v.size();i++){
         if(t[i]!=v[i]){
             return false;
         }
     }
     return true;
    }
};


// approch 3


/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
